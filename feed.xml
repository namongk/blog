<?xml version="1.0" encoding="utf-8" ?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko">
  <title type="xhtml">
    <div xmlns="http://www.w3.org/1999/xhtml">
      <ruby>洪民憙<rp>(</rp><rt>홍민희</rt><rp>)</rp></ruby>
      블로그
    </div>
  </title>
  <updated>2016-04-07T05:43:40+09:00</updated>
  <id>http://blog.hongminhee.org/feed.xml</id>
  <link rel="alternate" type="text/html" hreflang="ko"
        href="http://blog.hongminhee.org/index.html" />
  <link rel="self" type="text/xml" hreflang="ko"
        href="http://blog.hongminhee.org/feed.xml" />
  <rights>Copyright &#169; Hong Minhee</rights>
  <generator uri="https://github.com/dahlia/blog">
    Hong Minhee&#39;s blog
  </generator>
  <subtitle type="xhtml">
    <div xmlns="http://www.w3.org/1999/xhtml">
      <ul class="disclaimer">
        <li>글을 썼을 당시의 주장에 제 스스로가 더이상 동의하지 못하는
            경우도 있습니다.</li>
        <li>심지어 몇몇 글은 이제 정 반대의 의견을 가지고 있기도 합니다.</li>
        <li>지금까지 여러 주제에 대한 의견이 꾸준히 달라졌습니다.
            앞으로도 그럴 것입니다.</li>
        <li>따라서 제 생각을 바꾸기 위한 설득도 환영합니다.
            저는 의견을 바꿀 의향이 있습니다.</li>
      </ul>
    </div>
  </subtitle>
  
    <entry>
      
        
          <title>6년만의 블로그 이전</title>
        
        <id>http://blog.hongminhee.org/2016/04/07/new-blog-url/</id>
        <link rel="alternate" type="text/html" hreflang="ko"
              href="http://blog.hongminhee.org/2016/04/07/new-blog-url/" />
        <published>2016-04-07T05:43:40+09:00</published>
        <updated>2016-04-07T05:43:40+09:00</updated>
        <author>
          <name>홍민희</name>
          <uri>http://hongminhee.org/</uri>
          <email>&#104;ongmin&#104;ee&#64;member&#46;fsf&#46;org</email>
        </author>
        <content type="html">&lt;h1 id=&#34;년만의-블로그-이전&#34;&gt;6년만의 블로그 이전&lt;/h1&gt;
&lt;p&gt;원래 Tumblr에서 호스팅하던 블로그를 옮겼다. &lt;a href=&#34;http://blog.hongminhee.org/2010/02/09/379524623/&#34;&gt;2010년 초에 Tumblr로 옮긴&lt;/a&gt; 뒤 6년만의 블로그 이사이다. Tumblr를 떠나게 된 계기는 최근부터 내가 쓴 글에 달린 링크를 가로채서 다른 URL로 바꿔치기 하도록 업데이트됐기 때문이다.&lt;/p&gt;
&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;en&#34;&gt;&lt;p lang=&#34;ko&#34; dir=&#34;ltr&#34;&gt;방금 알았는데 Tumblr가 언제부터인가 내가 글에서 링크한 URL을 가로채서 자기네 중간 리다이렉션 페이지를 거치도록 바뀐 URL을 삽입해놨다. 옵션을 찾아봐도 끄는 방법을 찾을 수 없다. 지금까지는 떠날 이유도 없고 귀찮아 냅뒀지만, 슬슬 옮겨야.&lt;/p&gt;&amp;mdash; Hong Minhee ・ 洪 民憙 (@hongminhee) &lt;a href=&#34;https://twitter.com/hongminhee/status/716599931432140801&#34;&gt;April 3, 2016&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;//platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;p&gt;몇년 전부터 정적 사이트 생성기로 블로그 만드는 게 프로그래머 사이의 유행이 되어서 나 역시 옮기고 싶다고 생각했었는데, 막상 귀찮아서 생각만 하다가 계기가 생겨서 이참에 옮기게 되었다.&lt;/p&gt;
&lt;p&gt;새 블로그 주소는 &lt;a href=&#34;http://blog.hongminhee.org/&#34; class=&#34;uri&#34;&gt;http://blog.hongminhee.org/&lt;/a&gt;이다. 참고로 이전 블로그의 모든 퍼머링크들은 내가 오기와 집념으로 거의 다 리다이렉션(&lt;code&gt;301 Moved Permanently&lt;/code&gt;) 시켰다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://jekyllrb.com/&#34;&gt;Jekyll&lt;/a&gt; 같은 훌륭한 정적 사이트 생성기도 있고,&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 그 외에도 다양하게 존재하지만, 예전부터 내가 원하는 정적 사이트 생성기의 조건은 어느 정도 확립되어 있었다. 그 중 가장 중요한 조건은 &lt;a href=&#34;http://blog.hongminhee.org/2010/02/09/379524623/&#34;&gt;2010년에 Tumblr로 블로그를 이사했을 때&lt;/a&gt;나 지금이나 같은데, Markdown을 어떤 식으로 지원하느냐다. 지금까지 6년동안 블로그에 올렸던 모든 글을 제대로 빌드할 수 있어야 하기 때문이다. 10년 전부터 Markdown Extra 문법을 사용해왔고, 이 문법의 제대로 된 구현은 현재까지 내가 알기로는 레퍼런스 구현인 &lt;a href=&#34;https://michelf.ca/projects/php-markdown/extra/&#34;&gt;PHP Markdown Extra&lt;/a&gt;와 &lt;a href=&#34;http://pandoc.org/&#34;&gt;Pandoc&lt;/a&gt; 정도밖에 없다. 그래서 Pandoc을 Markdown 구현 백엔드로 사용하는 것들만 추리니 얼마 안 남았다. &lt;a href=&#34;https://jaspervdj.be/hakyll/&#34;&gt;Hakyll&lt;/a&gt; 같은 것들이 나왔는데, 처음 조금 시도해 보다가 포기하고 그냥 직접 만들기로 했다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://jaspervdj.be/hakyll/&#34;&gt;Hakyll&lt;/a&gt;에서 아쉬웠던 것은 자체 템플릿 엔진이 반복문을 두겹 이상으로 사용할 수 없다는 점이었다. 두 단계 이상으로 접혀 들어가는 내용을 다루기가 아주 까다로웠다. 사실 설정이 그냥 Haskell 코드라서 유연하다는 장점이 있었고, 분명 내가 좀더 파고들었으면 어떻게든 해결 가능했을 것이라는 생각이 든다. 실제로 해결 비슷하게 하긴 했는데, 다 하고 보니 상당양의 로직 코드를 만든 뒤라 허탈감이 왔다. 그 뒤에 &lt;code&gt;href&lt;/code&gt; 끝에 index.html 같은 것을 없애는 방법이라던가, 로컬 빌드에서는 &lt;code&gt;href&lt;/code&gt;를 만들 때 index.html을 붙이고, 실제로 배포할 때는 뺀 경로로 올리는 방법 같은 것을 찾아봤지만 그런 것은 별도 기능으로 있지 않았고, 모두 다 내가 직접 구현을 해야 했다. RSS 등 몇가지 더 원하는 기능이 있었는데, 하루 종일 코딩해서 일요일 하루를 날리고 보니 인내심이 사라져서 Hakyll은 버리기로 했다.&lt;/p&gt;
&lt;p&gt;내게 남은 휴일이 얼마 없다보니 조급해졌는데, 그래서 대충 쉘 스크립트로 Pandoc을 엮어서 결과물을 얼른 내놓기로 했다. 첫 구현은 썩 잘 돌아갔는데, 아카이브 페이지나 첫 페이지 등을 만드려면 템플릿 엔진 비슷한 게 필요해졌다. 쉘 스크립트의 단순 문자열 치환으로는 HTML 중간에 반복되는 내용을 넣기가 어려웠기 때문이다. 아니, 넣을 수는 있었는데 나중에 수정할 수 없을 것 같은 코드가 나온다.&lt;/p&gt;
&lt;p&gt;그래서 쉘 스크립트를 대충 Python으로 옮겨 적기 시작했다. 하다보니 bash로는 쉽게 할 수 없는 추상화가 가능해져서, 하는 김에 일반화를 조금 하기도 했다. 이 정도까지 하니 졸린데다 주말이 다 사라져서 아쉽지만 다음날 이어서 작업하기로 했다. (다행히 휴가 하루 냈었다.)&lt;/p&gt;
&lt;p&gt;최종적으로 만든 정적 사이트 생성기는 전적으로 내 블로그에서만 쓸 수 있도록 일반화가 거의 안 되어 있는 &lt;a href=&#34;https://github.com/dahlia/blog/blob/master/gen.py&#34;&gt;gen.py&lt;/a&gt; 스크립트다.&lt;a href=&#34;#fn2&#34; class=&#34;footnoteRef&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; 이걸 GitHub 저장소에 푸시할 때마다 자동으로 빌드되게 하고 싶어서 &lt;a href=&#34;https://github.com/dahlia/blog/blob/master/.travis.yml&#34;&gt;Travis CI를 활용했다.&lt;/a&gt; 그리고 빌드된 결과는 다시 GitHub Pages로 푸시된다. 결과적으로 새 블로그는 딱히 오픈 소스도 아니건만 오픈 소스를 위한 공공 인프라를 무전취식하고 있다.&lt;/p&gt;
&lt;p&gt;하여간, 그리고 Tumblr에 올라가 있던 글을 다 옮겨와야 했다. 사실은 이 작업을 더 먼저 했다. &lt;a href=&#34;https://github.com/dahlia/blog/tree/migrate&#34;&gt;이쪽도 Tumblr API를 써서 평범하게 Python 스크립팅으로 끝냈다.&lt;/a&gt; 한번 쓰고 버릴 스크립트다보니 더더욱 오늘만 사는 심정으로 얼렁뚱땅 짰지만, 그럭저럭 잘 돌아갔다.&lt;/p&gt;
&lt;p&gt;마지막으로 기존 URL을 새 URL로 리다이렉션시키는 작업에 착수했다. 내가 생각한 방법은, 리다이렉션만 해주는 간단한 서버를 작성하고, 기존에는 Tumblr에 물려있던 blog.dahlia.kr 도메인을 해당 서버로 돌려 물리는 것이었다. &lt;a href=&#34;https://github.com/dahlia/blog/blob/redirector/index.json&#34;&gt;우선 기존 Tumblr의 글 목록과, 각 글의 새 URL을 담고 있는 테이블을 만들었다.&lt;/a&gt; 다행히 Tumblr 글을 마이그레이션하는 스크립트의 출력 결과를 가져다가 기계적으로 구성할 수 있었다. &lt;a href=&#34;https://github.com/dahlia/blog/blob/redirector/redir.py&#34;&gt;그리고 Flask를 써서 간단한 리다이렉션 서버까지 작성했다.&lt;/a&gt; 서버는 &lt;del datetime=&#34;2016-04-08T02:14:59+09:00&#34;&gt;Heroku&lt;/del&gt;&lt;ins
datetime=&#34;2016-04-08T02:14:59+09:00&#34;&gt;Google App Engine&lt;/ins&gt;&lt;a href=&#34;#fn3&#34; class=&#34;footnoteRef&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;에 공짜 앱으로 배포하고, DNS 레코드를 수정하여 blog.dahlia.kr가 더이상 Tumblr 서버를 바라보지 않게 만들었다.&lt;/p&gt;
&lt;p&gt;(공짜 &lt;del datetime=&#34;2016-04-08T02:14:59+09:00&#34;&gt;Heroku&lt;/del&gt;&lt;ins
datetime=&#34;2016-04-08T02:14:59+09:00&#34;&gt;Google App Engine&lt;/ins&gt;&lt;a href=&#34;#fn4&#34; class=&#34;footnoteRef&#34; id=&#34;fnref4&#34;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; 서버에 Travis CI, GitHub Pages 등… &lt;a href=&#34;http://blog.hongminhee.org/2013/12/21/70680247969/&#34;&gt;돈 한푼 안내고 서버 없이 무전취식하는&lt;/a&gt; 잔재주는 날이 갈수록 늘어난다.)&lt;/p&gt;
&lt;p&gt;내 블로그는 이제 10년째 운영중이다. 6년 전에 블로그 이사했을 때도 RSS 주소는 유지했다. 이제는 살아있는 시체가 되어버린 &lt;a href=&#34;http://feedburner.com/&#34;&gt;FeedBurner&lt;/a&gt;를 쓰고 있었기 때문이다. 하여간 아직 운영은 되고 있으니 들어가서 소스 URL을 Tumblr에서 제공하는 RSS에서 새 블로그의 RSS로 옮겼다. 아마 RSS 리더로 구독해서 보고 있던 분들은 (이미 읽었던 글이 새 글로 좀 뜰 수도 있겠지만) 그대로 이어서 구독할 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;이렇게 하면 거의 다 한 것 같았는데, 생각해보니 내 기존 블로그는 Tumblr 팔로워도 상당히 많았다. (사실 그것도 Tumblr 탈출을 망설이게 한 요인이다.) 어쩔까 하다가 기존에 올라온 글 내용을 몽땅 수정해서, 각 글의 새 URL로 링크해주기로 했다. &lt;a href=&#34;https://github.com/dahlia/blog/blob/redirector/edit.py&#34;&gt;이것 역시 손으로 할 수는 없으니 스크립트를 짰다.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;여기까지 해보니 블로그 하나 옮기겠다고 온갖 삽질을 한 것 같아 보인다. 맨 처음 이사는 3년 블로깅 후에 한 것이었고, 이번 이사는 그 뒤로 6년 블로깅한 후에 옮긴 것이니, 귀찮아서 앞으로 12년간은 블로그 이사는 하지 않으련다.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;더구나 &lt;a href=&#34;https://jekyllrb.com/&#34;&gt;Jekyll&lt;/a&gt;을 쓰면 GitHub Pages에서 빌드까지 돌려준다.&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;저 스크립트가 들어있는 &lt;a href=&#34;https://github.com/dahlia/blog/tree/master&#34;&gt;블로그 저장소&lt;/a&gt;의 다른 문서나 스크립트들은 그렇지 않지만, &lt;a href=&#34;https://github.com/dahlia/blog/blob/master/gen.py&#34;&gt;gen.py&lt;/a&gt; 스크립트만은 GPLv3이다.&lt;a href=&#34;#fnref2&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://twitter.com/hongminhee/status/718059459919020032&#34;&gt;Heroku 무료 앱에는 사용량 제한이 있어서 늦은 시간이 되자 서버 오류가 나기 시작했다.&lt;/a&gt; 그래서 &lt;a href=&#34;https://twitter.com/hongminhee/status/718124928243879936&#34;&gt;Google App Engine으로 교체했다.&lt;/a&gt;&lt;a href=&#34;#fnref3&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn4&#34;&gt;&lt;p&gt;&lt;a href=&#34;https://twitter.com/hongminhee/status/718059459919020032&#34;&gt;Heroku 무료 앱에는 사용량 제한이 있어서 늦은 시간이 되자 서버 오류가 나기 시작했다.&lt;/a&gt; 그래서 &lt;a href=&#34;https://twitter.com/hongminhee/status/718124928243879936&#34;&gt;Google App Engine으로 교체했다.&lt;/a&gt;&lt;a href=&#34;#fnref4&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>
      
    </entry>
  
    <entry>
      
        
          <title>2016년 4월 3일</title>
        
        <id>http://blog.hongminhee.org/2016/04/03/142164655247/</id>
        <link rel="alternate" type="text/html" hreflang="ko"
              href="http://blog.hongminhee.org/2016/04/03/142164655247/" />
        <published>2016-04-03T15:53:59+09:00</published>
        <updated>2016-04-03T15:53:59+09:00</updated>
        <author>
          <name>홍민희</name>
          <uri>http://hongminhee.org/</uri>
          <email>&#104;ongmin&#104;ee&#64;member&#46;fsf&#46;org</email>
        </author>
        <content type="html">&lt;p&gt;1Password 쓰게 된 계기는 5년 전쯤 국내 모 대형 사이트가 개인정보를 해킹당하게 되면서였다. 나는 여러 사이트에서 거의 같은 암호 서너 개를 돌려가며 사용하고 있었고, 기껏해야 사이트마다 암호에 살짝의 변형을 주는 것이 전부였다. 가령 평소 사용하는 암호가 &lt;code&gt;asdf&lt;/code&gt;이고 가입하려는 사이트가 abc.com이면 대충 &lt;code&gt;abc_asdf&lt;/code&gt; 같은 식으로 변형을 하는 정도였다. 그런데 그 사이트가 털렸단다.&lt;/p&gt;
&lt;p&gt;그 사이트는 그때도, 그리고 사실 지금까지도 암호의 최대 길이나 사용할 수 있는 기호에 제한을 두고 있었다. 적절한 암호학적 해시를 하고 있다면 왜 구태여 그런 제한을 둔단 말인가? 그 사이트가 내 암호에 어떠한 종류의 암호학적 조치도 하지 않는다는 심증은 매우 강했다. 나는 프로그래머이면서도, 국내의 아주 많은 사이트에 가입할 때마다, 내 암호의 허용 범위에 대한 말도 안되는 안내 문구를 읽을 때마다, 그런 심증을 느껴왔으면서도 별 생각 없이 그렇게 살고 있었던 것이다. 그 사이트를 비롯해 매우 많은 웹 사이트는, 아마 그것을 구현하는 프로그래머의 배움에 대한 나태와 무지에 의해, 의도치 않게 대한민국 국민 대부분의 자주 쓰는 암호들을 평문으로 보존하고 있을 것이다. 그리고 보안 수준을 높이기 위한 명목으로 회원들에게 3개월마다 암호를 바꾸라고 강요하고 있는 것이다.&lt;/p&gt;
&lt;p&gt;내가 5년 전에 자주 쓰던 서너 개의 암호 중 최소한 하나는 공개된 정보가 되어버렸을 것이다. 그래도 찝찝함을 덜겠다고 암호 앞에 사이트 이름을 붙여놨지만, 누가 보든 암호 앞에 붙은 사이트 이름을 떼고 나면 그게 내 즐겨 쓰는 암호 중 하나라는 것을 알 수 있을 것이다.&lt;/p&gt;
&lt;p&gt;그날 바로 1Password를 구입하고 내가 기억하는 모든 로그인 암호를 무작위로 만들어서 바꿨다. 무작위 암호는 매번 그 사이트가 허용하는 최대 길이로 꽉꽉 채워서 생성했다. 더이상 사용하지 않는 서비스는, 우선 암호를 무작위로 변경하고 나서, 다시 탈퇴했다. 그들 사이트가 내가 탈퇴를 했다고 해서 내가 쓰던 암호를 평문으로 보존하는 것을 중단할 거라는 보장은 할 수 없었다. 이 작업은 하루아침에 끝나진 않았지만 꾸준히 하고 보니, 나는 내가 가입한 모든 서비스에서 서로 아주 다른 암호를 사용하게 되었다. 이제는 어느 사이트 하나가 크게 털려도, 나의 다른 계정까지 탈취하는 것은 막을 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;현실적인 이유에서, 적어도 대한민국의 웹 서비스들에서는 암호를 암호라고 인식해서는 안되게 됐다. 그 항목에 담겨야 할 것은 내가 직접 기억할 수 있는 암호가 아니라 나의 인증을 대리해주는 소프트웨어가 기계적으로 생성해주는 토큰 문자열이다. 현실적인 이유에서 그러해야 한다.&lt;/p&gt;
</content>
      
    </entry>
  
    <entry>
      
        
          <title>프로토콜이 간단하다는 말의 의미</title>
        
        <id>http://blog.hongminhee.org/2016/03/16/141092530227/</id>
        <link rel="alternate" type="text/html" hreflang="ko"
              href="http://blog.hongminhee.org/2016/03/16/141092530227/" />
        <published>2016-03-16T00:40:02+09:00</published>
        <updated>2016-03-16T00:40:02+09:00</updated>
        <author>
          <name>홍민희</name>
          <uri>http://hongminhee.org/</uri>
          <email>&#104;ongmin&#104;ee&#64;member&#46;fsf&#46;org</email>
        </author>
        <content type="html">&lt;h1 id=&#34;프로토콜이-간단하다는-말의-의미&#34;&gt;프로토콜이 간단하다는 말의 의미&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://medium.com/@paulcolomiets/the-future-of-asynchronous-io-in-python-ce200536d847&#34;&gt;The HTTP must not be used for internal messaging as it’s easy, but not simple, quite the contrary it’s complicated protocol with 5 RFCs describing only basics. And misunderstanding smallest part of spec may lead to a security vulnerability.&lt;/a&gt; (via &lt;a href=&#34;http://blog.materialistic.kr/post/141087802693&#34;&gt;Materialistic&lt;/a&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;어떤 표준 명세가 길고 복잡하다는 것과, 그 표준이 &lt;em&gt;활용하기에&lt;/em&gt; 복잡하다는 것은 실무에서 꽤나 분리된 이야기다. HTTP를 바닥부터 구현하려면 할 게 매우 많다는 것은 자명하다. 하지만 HTTP를 활용하기 위해 HTTP를 직접 구현할 사람이 얼마나 되겠는가?&lt;/p&gt;
&lt;p&gt;구조의 복잡함이란 구조를 위해 우리가 갖추고 있는 재료(primitives)에 상대적으로 평가되는 것이다. &lt;a href=&#34;http://blog.dahlia.kr/post/21013840165&#34;&gt;예전에 썼던 글&lt;/a&gt;을 끌고 오자면,&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;관계형 데이터베이스가 고수준이라는 것은 우리가 현대에 사용하고 있는 전자 컴퓨터가 제공하는 프리미티브 위에서 복잡하게 구현해야 한다는 것을 뜻한다. 전자 컴퓨터가 제공하는 프리미티브는 우리가 수준&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;을 얘기할 때 생략되지만 암시적으로 가리키는 것이다. CSS 렌더링 엔진은 Linux보다 고수준이다. 하지만 JavaScript 프로그래머 입장에서는 CSS 렌더링은 프리미티브에 한없이 가까운 저수준이며 &lt;a href=&#34;http://bellard.org/jslinux/&#34;&gt;jslinux&lt;/a&gt;는 매우 고수준의 달성 과제이다. 전자 컴퓨터 위에서 구현하는 간단한 트리는 관계형 데이터베이스보다 훨씬 저수준이지만, 당연히 관계형 데이터베이스 위에서 nested set model로 구현하는 트리는 아무 것도 하지 않아도 이미 그 자리에 있는 관계형 데이터베이스에 비해 고수준이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HTTP는 클라우드 시대의 TCP가 되어버렸고, 현대의 프로그래밍 언어들은 HTTP 통신을 마치 파일 입출력 다음으로 흔한 것처럼 대우해준다. 요즈음 실무에서 네트워크 프로그래밍을 하려는데 HTTP만큼 프리미티브로 취급되는 빌딩 블럭도 소켓을 제외하면 찾기 힘들 것이다.&lt;/p&gt;
&lt;p&gt;HTTP의 RFC 명세가 길고 복잡한데도 간단하다고 말하는 것은, IBM 호환 PC가 복잡한 물리적 구성요소로 이루어져 있음에도 구성하기에 간단하다고 하는 것과 비슷한 표현이다.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;고수준이다 혹은 저수준이다 말할 때의 수준을 뜻한다.&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>
      
    </entry>
  
    <entry>
      
        
          <title>2015년 12월 13일</title>
        
        <id>http://blog.hongminhee.org/2015/12/13/135096412217/</id>
        <link rel="alternate" type="text/html" hreflang="ko"
              href="http://blog.hongminhee.org/2015/12/13/135096412217/" />
        <published>2015-12-13T15:01:36+09:00</published>
        <updated>2015-12-13T15:01:36+09:00</updated>
        <author>
          <name>홍민희</name>
          <uri>http://hongminhee.org/</uri>
          <email>&#104;ongmin&#104;ee&#64;member&#46;fsf&#46;org</email>
        </author>
        <content type="html">&lt;p&gt;&lt;img src=&#34;https://41.media.tumblr.com/595c0a6304234f04874fb7563c0db767/tumblr_nza8qotT3P1qz6t91o1_1280.jpg&#34; /&gt;&lt;/p&gt;
&lt;p&gt;오늘도 프로그래밍과 아무 관계 없는 얘기를 써본다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.soylent.com/&#34;&gt;Soylent&lt;/a&gt;로 점심을 때운지 두 달 남짓 됐다. Soylent는 이른바 &lt;a href=&#34;https://en.wikipedia.org/wiki/Meal_replacement&#34;&gt;식사를 대체&lt;/a&gt;하는 것을 목표로 한 제품으로, 그런 종류의 제품 중에서 가장 먼저 널리 알려진 것이다. (앞서 Premist 님이 썼던 리뷰 &lt;q&gt;&lt;a href=&#34;http://si.mpli.st/review/soylent-week-1.html&#34;&gt;Soylent 1주일 후기&lt;/a&gt;&lt;/q&gt;도 읽어볼 것을 권한다.) 쉽게 얘기해서 그것만 먹고 살아도 영양 불균형으로 인해 병이 나거나 죽을 걱정을 하지 않아도 되는 식품을 목표로 한다고 보면 된다.&lt;/p&gt;
&lt;p&gt;내가 먹어본 버전은 1.5와 2.0 두 개인데, 1.5는 Soylent 첫 버전부터 꾸준히 발전해온 분말 유형이고 봉투에 담겨서 온다. 2.0은 최근에 새로 나온 것인데 이미 음료 형태로 완성이 된 상태로 병에 담겨서 온다.&lt;/p&gt;
&lt;p&gt;처음에는 2.0의 맛이 더 깔끔하고 군더더기가 없어서 선호했으나, 번갈아 먹다보니 몇일 지나지 않아 식사라는 느낌을 조금이나마 더 주는 1.5를 선호하게 됐다. 2.0에 비해 1.5는 호두 냄새 같은 게 더 나고, 살짝 건더기 느낌도 난다. 1.5는 &lt;q&gt;먹는&lt;/q&gt; 느낌이 좀 나는데, 2.0는 &lt;q&gt;마시는&lt;/q&gt; 느낌이다. 게다가 2.0은 정량이 정해져 있는데, 그 양이 내게는 좀 부족한 정도였다. 점심을 2.0으로 때우면 5시쯤에는 벌써 심하게 배가 고파진다. 1.5는 분말을 통에 담고 물을 직접 섞어서 먹어야 하므로, 양은 자신이 원하는대로 정할 수 있다.&lt;/p&gt;
&lt;p&gt;물론 빠르고 편하게 먹자는 이유로 Soylent를 먹는 것도 있는데, 그런 관점에서 보면 1.5는 2.0에 비해 손색이 있다. 은근히 통에 정량대로 가루를 담고 물 넣어서 흔드는 것도 일이다. 별 것 아닌 설거지도 귀찮다.&lt;/p&gt;
&lt;p&gt;그런 경험이 누적되어, 특별히 규칙을 정한 건 아니지만 대체로 1.5과 2.0 중 어떤 것을 먹을지 정하는 기준 같은 게 생기긴 했다. 지각했을 때, 지금 당장 회의 들어가야 하는데 식사 못 했을 때, 아침에 일어나서 입맛이 하나도 없는데 배가 비어 뭐라도 먹어야 할 때, 자정에 배가 고픈데 2시간 안에 잘 것 같을 때는 2.0을 마신다. 자정에 2.0을 뜯는 이유는 양이 적고 밤에 설거지하기 귀찮기 때문이다. 그 외에는 보통 1.5를 먹는다.&lt;/p&gt;
&lt;p&gt;맛에 관해서는, 나는 어떤 음식이 맛있는 음식인지 잘 모르지만, 먹을만 했다. 앞서 얘기했듯 2.0이 더 깔끔해서 처음 먹을 때는 거부감이 들지 않는다. 1.5는 처음 먹으면 살짝 거부감이 드는데, 익숙해지면 오히려 거부감을 주었던 그 향이 더 식사 같은 느낌을 줘서 선호하게 되는 듯하다. 어쨌든 둘 다 똥맛은 아니다. 직장 동료는 1.5가 똥맛은 아니지만 흙맛이 난다는 얘기는 했던 것 같다.&lt;/p&gt;
&lt;p&gt;다만 모든 식사를 Soylent로 때우기에는 나도 아직 미래인이 될 준비가 되지 못했다. 처음 시도할 때는 연속으로 다섯 끼니 정도를 Soylent로 해결하기도 했지만, 나는 누구보다 짠맛과 MSG의 감칠맛를 사랑하기 때문에 그러한 자극적인 느낌이 그리워졌던 것이다. 그래서 주말에 집구석에 박혀서 식사는 대충 때우고 싶을 때, 점심은 Soylent로 때우고 저녁은 라면이나 스팸에 밥만 먹기도 한다.&lt;/p&gt;
&lt;p&gt;이러한 식사 대체품으로는 Soylent 외의 여러 대안 제품들이 나오고 있다. 국내에도 벌서 여러 종류가 나와 있다. 회사에서 이러한 식사 대체품(회사 안에서는 &lt;q&gt;미래 식량&lt;/q&gt;이라고 불리고 있고 Slack 채널이 따로 있다)에 대한 유행이 생겨서, 다들 이것 저것 서베이하고 도전해보았다. 나도 동료가 주문한 &lt;a href=&#34;http://labnosh.com/&#34;&gt;랩노쉬&lt;/a&gt;라는 국산 제품을 시도해 보았는데, 초콜렛 맛과 구운 오징어 냄새가 섞여있는 느낌을 참을 수 없어서 한 통을 다 비우지 못했다. 물론 이는 전적으로 개인적인 경험으로, 동료들 중에서는 오히려 Soylent보다 랩노쉬가 낫다면서 만족한 사람도 여럿 있다.&lt;/p&gt;
&lt;p&gt;Soylent는 한국에서 가격적인 디메리트가 있다. 배송 대행을 거쳐야 하기 때문이다. 관세도 적지 않고, 특히 2.0은 무게가 나가기 때문에 배송비가 많이 나간다. 이런 점 때문에 국산을 찾는 동료가 많았다. 나 같은 경우 2.0은 가격이 부담되기 때문에 더이상 주문하지 않고 1.5만 주문하려고 한다.&lt;/p&gt;
&lt;p&gt;의도하지 않았던 장점도 하나 더 있었다. 내게만 해당될 듯하지만, 원체 소화 불량이 심해서 적어도 보름에 1번은 체하는 경우가 있었는데, Soylent로 점심을 먹고 나서는 체하는 경우가 아직 없었다. 뭐, 이걸 먹어서 체한 게 사라진 건 아닐 수도 있지만.&lt;/p&gt;
</content>
      
    </entry>
  
    <entry>
      
        
          <title>텀블러 같은 나라</title>
        
        <id>http://blog.hongminhee.org/2015/11/08/132783105357/</id>
        <link rel="alternate" type="text/html" hreflang="ko"
              href="http://blog.hongminhee.org/2015/11/08/132783105357/" />
        <published>2015-11-08T16:14:18+09:00</published>
        <updated>2015-11-08T16:14:18+09:00</updated>
        <author>
          <name>홍민희</name>
          <uri>http://hongminhee.org/</uri>
          <email>&#104;ongmin&#104;ee&#64;member&#46;fsf&#46;org</email>
        </author>
        <content type="html">&lt;h1 id=&#34;텀블러-같은-나라&#34;&gt;텀블러 같은 나라&lt;/h1&gt;
&lt;p&gt;작년인가 재작년인가, 트위터에서 누군가 이런 얘기를 했던 걸 본 적이 있다. 한국은 텀블러 같은 나라라고. 나는 그 얘기가 무척 와닿고 정말 그렇다고 여겼다.&lt;/p&gt;
&lt;p&gt;요즘 자주 돌아다니는 짤방 중에 경주와 교토를 비교한 짤방이 있다.&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://plus.google.com/photos/+KevinKelly/albums/6079085228418710065/6079085263509683266?pid=6079085263509683266&amp;amp;oid=116416314233992548280&#34;&gt;&lt;img src=&#34;https://lh6.googleusercontent.com/-q2XxmdD9vhg/VF0_1rrOfEI/AAAAAAAAYQw/Nv94qIViloQ/w3891-h2918/P1420249.jpg&#34; alt=&#34;Japan’s Nakasendo Walk&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.flickr.com/photos/mambo1935/1951225952/&#34;&gt;&lt;img src=&#34;https://c1.staticflickr.com/3/2027/1951225952_bbea033904_o_d.jpg&#34; alt=&#34;慶州市 — Gyeongju City, Korea&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://larca.egloos.com/4099397&#34;&gt;정확히는 경주 사진은 10년 전 모습이라고 하고, 일본 사진도 교토가 아닌 나라이라는 동네라고 한다.&lt;/a&gt; 한쪽은 10년 전 사진이고, 한쪽은 교토도 아니라고 하지만, 사람들의 한국과 일본에 대한 이미지를 극적으로 대비시키기 때문에 다들 퍼나르는 것이라고 생각한다. 즉, 사실은 아니지만 저 대비 구도는 일정 부분 진실된 점이 있다는 것이다.&lt;/p&gt;
&lt;p&gt;이번에는 거리가 아닌 일상의 휴대전화 사용을 떠올려 보자. 다음은 구글에서 &lt;q&gt;스마트폰 알림&lt;/q&gt;으로 검색해서 나온 이미지이다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://image.itdonga.com/files/2014/02/21/1_1.jpg&#34; alt=&#34;검색어: 스마트폰 알림&#34; /&gt;&lt;/p&gt;
&lt;p&gt;또 &lt;q&gt;smartphone notifications screen&lt;/q&gt;으로도 검색해 보았다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;http://imagescdn.tweaktown.com/content/6/7/6778_66_tweaktown_s_apple_iphone_6_plus_smartphone_review.png&#34; alt=&#34;검색어: smartphone notifications screen&#34; /&gt;&lt;/p&gt;
&lt;p&gt;전부터 느꼈던 것이지만, 우리나라의 양식 전반에 걸쳐서 자주 나타나는 특징 같은 게 있다고 여겨진다. 트위터에서는 누군가 그것을 &lt;q&gt;텀블러 같다&lt;/q&gt;고 표현했는데, 텀블러에 로그인하면 나오는 대시보드 역시 포스트 사이의 연속성, 일관성이 매우 결여되어 있기 때문이다. 대신 그 포스트 하나하나는 매우 특색이 있고 강렬하다는 특징도 있다.&lt;/p&gt;
&lt;p&gt;나는 그게 일종의 자기 완전성 같은 것이라고 느낀다. 무언가를 만듦에 있어, 결과물은 어떤 맥락에서도 뛰어나야 한다. 그렇기 때문에 &lt;em&gt;주변 맥락으로부터 독립적&lt;/em&gt;이어야 한다. 우리가 만들어낸 결과가 어떤 자리에 놓일지보다, 결과 자체의 완전성이 더 중요해진다.&lt;/p&gt;
&lt;p&gt;한국에서 자기 완전성은 예전부터 중요했고, 이는 사람에게도 적용되고, 사업에도 적용된다. 그렇지만 나는 한국의 이런 경향이 필연적인 것이라고는 생각하지 않는다. 매사에 자기 완전성과 개별의 뛰어남이 중요하게 여겨지는 이유는 거의 모든 결과에 대한 (실패했을 때의) 책임과 (성공했을 때의) 혜택이 개인에게 한정되는 사회 분위기가 강하기 때문이다. &lt;q&gt;서로 조화를 이뤄야 한다&lt;/q&gt; 같은 협력적 가치보다는 &lt;q&gt;가장 돋보여야 한다&lt;/q&gt; 같은 경쟁적 가치가 중요하게 여겨지는 것도 책임/혜택을 개인에게 한정시키는 문화와 밀접한 연관이 있다고 느낀다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Culture_of_honor_%28Southern_United_States%29&#34;&gt;명예 문화&lt;/a&gt;(culture of honor)라는 용어가 있다. 오랜 기간 공공 치안이 떨어졌던 곳에서는 개인의 명예를 중요시하는 문화가 강해진다는 것이다. 그리하여 개인이 당한 부당한 일에 대해 개인 스스로가 단호하게 보복하는 전통까지 생긴다. 이는 치안이 없는 사회에서 그러한 부당한 일이, 적어도 보복을 한 그 개인이나 집에 대해서는, 지속적으로 일어나지 않게 방지해주는 효과가 있다. 하지만 반대로 얘기하면 공공 치안이 뛰어나다면 그런 야만적인 문화는 점차 억제된다고 볼 수 있다.&lt;/p&gt;
&lt;p&gt;나는 비슷하게 한국의 이러한 분위기도 일종의 자기 완전성 문화라고 불러보고 싶고, 협력/조화보다 경쟁을 중요시하는 분위기가 완화되면 그와 연관된 자기 완정성의 문화도 점차 줄 수 있지 않을까 하는 생각이 든다.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;원본 출처가 없이 돌아다니길래 출처를 열심히 찾았다. 사진에 걸린 링크를 누르면 사진을 처음 올린 곳이 나온다.&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>
      
    </entry>
  
    <entry>
      
        
          <title>“한글”은 이제 한국어를 포함한다</title>
        
        <id>http://blog.hongminhee.org/2015/10/09/130798016527/</id>
        <link rel="alternate" type="text/html" hreflang="ko"
              href="http://blog.hongminhee.org/2015/10/09/130798016527/" />
        <published>2015-10-09T14:42:40+09:00</published>
        <updated>2015-10-09T14:42:40+09:00</updated>
        <author>
          <name>홍민희</name>
          <uri>http://hongminhee.org/</uri>
          <email>&#104;ongmin&#104;ee&#64;member&#46;fsf&#46;org</email>
        </author>
        <content type="html">&lt;h1 id=&#34;한글은-이제-한국어를-포함한다&#34;&gt;&lt;q&gt;한글&lt;/q&gt;은 이제 한국어를 포함한다&lt;/h1&gt;
&lt;p&gt;해마다 한글날이 되면 &lt;q&gt;한글과 한국어는 다른 것이다&lt;/q&gt;라는 말을 하는 것도 이제 지겹다. 매해 그런 주장을 트위터나 페이스북에 써오다, 이제는 생각을 바꾸게 되었다.&lt;/p&gt;
&lt;p&gt;사람들은 정말로 문자와 입말의 개념을 혼동해서 한국어를 한글이라고 부르는 것이 아니다. 모호성을 제거하기 위해 &lt;q&gt;한글 글자&lt;/q&gt;, &lt;q&gt;한글 문자&lt;/q&gt;라 지칭하면 사람들은 곧바로 그것이 입말이 아닌 문자를 뜻한다는 것을 알아본다. 반대로 &lt;q&gt;한국말&lt;/q&gt;, 혹은 좀더 명확하게 &lt;q&gt;입으로 하는 한국말&lt;/q&gt;이라고 해도 역시 사람들은 그것이 문자가 아닌 입말을 뜻한다는 것을 잘 알아듣는다.&lt;/p&gt;
&lt;p&gt;요는 &lt;q&gt;한글&lt;/q&gt;이라는 낱말에 대한 혼동은 아주 표면적인 수준의 혼동일 뿐, 실제 개념상의 혼동으로 볼 수는 없다는 것이다. 비슷하게 사람들은 영어 등의 유럽 언어를 표기하기 위해 쓰이는 &lt;q&gt;로마자&lt;/q&gt;와 &lt;q&gt;영어&lt;/q&gt;를 혼동하는데, 이는 정말로 사람들이 프랑스어나 독일어에서는 영어와 전혀 다른 문자를 쓴다고 믿어서 그런 것은 아니다. 단지 &lt;q&gt;로마자&lt;/q&gt;라는—주로 언어학적 엄밀성이 요구되는 맥락이 아니면 쓰일 일 없는—유용한 낱말을 아직 마주한 적 없거나 생소하기 때문에 그렇게 표현하지 못하는 것이다.&lt;/p&gt;
&lt;p&gt;그러면 문자 한글을 가리키기 위해서 우리는 어떤 말을 써야 할까? 위에서 힌트를 주었지만, 내게는 두 가지 생각이 떠오른다.&lt;/p&gt;
&lt;p&gt;첫번째 생각은 아주 나이브하다. 대부분의 맥락에서 우리는 언어학적 엄밀성을 요구하지 않는다. 따라서 대부분은 모호하더라도 &lt;q&gt;한글&lt;/q&gt;이 한국어를 뜻하는지 한글 문자를 뜻하는지 명확히 가리지 않아도 괜찮다. 사실은 &lt;q&gt;한글&lt;/q&gt;과 &lt;q&gt;한국어&lt;/q&gt;를 아주 명확하게 구분하는 사람들이 매해 한글날 마다 &lt;q&gt;한글은 문자 체계지 언어가 아니다&lt;/q&gt;라고 지적할 수 있다는 것 자체가, 사람들이 편하게 한국어를 &lt;q&gt;한글&lt;/q&gt;이라고 지칭하는 것에 대해 아무 문제 없이 이해할 수 있기 때문에 가능한 것이다. 지적하는 사람들은 한국어를 가리키는데 &lt;q&gt;한글&lt;/q&gt;이라는 말을 쓰면 정말 혼란스럽고 언어 생활이 불편하기 때문에 그런 지적을 하는 것이 아니다. 그냥 사람들이 &lt;q&gt;한글&lt;/q&gt;을 좀더 넓은 뜻으로 쓰이는 것을 알고도 받아들이지 않는 것이다. 이 블로그에서 두 관점의 대립에 대해서는 여러 차례 언급했지만, 다시 언급하자면, &lt;q&gt;한글&lt;/q&gt;의 사전적 정의가 먼저 존재하고 이를 사람들이 따라야 한다는 관점을 &lt;a href=&#34;https://en.wikipedia.org/wiki/Linguistic_prescription&#34;&gt;prescriptivism&lt;/a&gt;이라고 한다. 한편 사람들이 이미 &lt;q&gt;한글&lt;/q&gt;이라는 말을 어떤 뜻으로 쓰고 있고, 그것이 그 말의 사전적 정의가 되어야 한다는 관점을 &lt;a href=&#34;https://en.wikipedia.org/wiki/Linguistic_description&#34;&gt;descriptivism&lt;/a&gt;이라고 한다. 양 관점의 중간에서 현명한 줄타기를 해야겠으나, 나는 &lt;q&gt;한글&lt;/q&gt;의 의미에 대한 갈등은 언중(言衆)을 바꾸려는 노력을 하기 보다는 사전적 정의를 현실에 맞게 고치는 것이 더 낫다고 믿는다.&lt;/p&gt;
&lt;p&gt;두번째 아이디어는 언어의 아주 유용한 특성인 redundancy를 활용하는 것이다. 어려운 말을 썼지만, 같은 뜻의 다른 말을 겹치면 된다는 얘기이다. &lt;q&gt;한글 글자&lt;/q&gt;, &lt;q&gt;한글 문자&lt;/q&gt; 정도로 표현해도 아주 충분하다. 물론 이를 두고 사람들은 &lt;q&gt;역전(驛前)앞&lt;/q&gt;&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;이나 &lt;q&gt;에스페란토어&lt;/q&gt;&lt;a href=&#34;#fn2&#34; class=&#34;footnoteRef&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;, &lt;q&gt;PIN 번호&lt;/q&gt;&lt;a href=&#34;#fn3&#34; class=&#34;footnoteRef&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;와 같이 같은 뜻의 말을 두 번이나 중복해서 쓴다며 지적하거나 비웃을 것이다. 하지만 이는 비웃을 일이 전혀 아니며 언어의 아주 유용한 특성을 잘 활용한 것이다.&lt;/p&gt;
&lt;p&gt;현대 한국인은 한자 교육을 잘 받지 못하므로 &lt;q&gt;역전&lt;/q&gt;으로부터 한자 驛前을 분해하지 못한다. 한국인이 쓰는 한자어는 분명 분해되는 규칙이 있고, 이는 한문으로부터 유래했으므로 한자와 같은 식으로 분해될 경우가 많다. 하지만 일본어 &lt;q&gt;まえ&lt;/q&gt;(前)가 공간적/시간적 앞을 모두 뜻하는 것과 다르게, 한국어 &lt;q&gt;전&lt;/q&gt;(前)은 시간적 앞을 가리키는 뜻만 남아 더이상 공간적 앞을 뜻하는 식으로는 쓰이지 않는다. 그렇기 때문에 사람들은 대개 &lt;q&gt;역전&lt;/q&gt;의 &lt;q&gt;전&lt;/q&gt;이 공간적 앞을 뜻한다고 생각하지 않는 것이다. 뜻이 통하기 위해 뒤에 &lt;q&gt;앞&lt;/q&gt;을 붙이는 것은 매우 유용한 언어 활용이다.&lt;/p&gt;
&lt;p&gt;마찬가지로 대부분의 사람들은 에스페란토를 전혀 모른다. 에스페란토라는 말이 에스페란토로 민족이나 국가가 아닌 언어 자체를 뜻한다는 것은 대부분의 한국어 화자 입장에서는 알 수 없는 사실이다. 그러므로 &lt;q&gt;에스페란토어&lt;/q&gt;라고 뒤에 &lt;q&gt;어&lt;/q&gt;(語)를 붙여 이게 어디서 쓰이는 말인지는 몰라도, 하여간 어떤 언어를 뜻한다는 것을 명확히하는 것은 도움이 되는 것이다.&lt;/p&gt;
&lt;p&gt;사실 이러한 redundancy는 문법적인 수준에서도 많이 등장하는데, 우리는 &lt;q&gt;학교 간다&lt;/q&gt;라고만 말해도 알아듣지만 문어적으로는 모호성을 줄이기 위해 일부러 중복되는 뜻의 말인 &lt;q&gt;나는&lt;/q&gt;이나 격 조사 &lt;q&gt;에&lt;/q&gt;를 붙여서 &lt;q&gt;나는 학교에 간다&lt;/q&gt;라는 식으로 문장을 구성한다. 하지만 입말을 쓰더라도 시끄러운 장소 등에서 전달이 어려울 때는, 다시 한번 말할 때 저러한 조사를 붙이거나 중복되는 의미를 연달아 말해서 redundancy를 높인다. 언어의 redundancy는 여러 상황에서 실제로 유용하기 때문에 추가된 것이고 모든 언어에서 보편적으로 관찰된다.&lt;/p&gt;
&lt;p&gt;딴소리를 너무 많이 했다. 돌아와서 세종대왕이 한글을 창제한 이유를 떠올려보자. 세종은 글조차 모르는 백성이 실제로 쓰고 있는 말을 위한 글을 만들고, 정음(正音)이라 하였다. 나는 이렇게 받아들인다. 똑바른 말이란 사람들이 실제로 널리 쓰는 말이다. 한글은 &lt;q&gt;한국어&lt;/q&gt;라는 뜻으로도 이미 널리 쓰이고 있다. 한글의 뜻이 무엇인지는 이제 분명해진다.&lt;/p&gt;
&lt;p&gt;덧. 다니는 회사에서 한글날을 기념해 &lt;a href=&#34;http://www.spoqa-han-sans.com/&#34;&gt;스포카 한 산스&lt;/a&gt;라는 서체를 무료로 배포하게 되었다. 오픈 폰트 라이센스이므로 사용 뿐만 아니라 수정도 자유롭다. 아무쪼록 유용하게 쓰였으면 하는 바람이다.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;어떤 사람들은 &lt;q&gt;역전앞&lt;/q&gt;의 전(前)이 &lt;q&gt;앞&lt;/q&gt;이라는 뜻이므로 뜻이 중복되어 바른 말이 아니라는 얘기를 한다.&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;어떤 사람들은 &lt;q&gt;에스페란토&lt;/q&gt;라는 말 자체가 언어를 가리키므로 &lt;q&gt;어&lt;/q&gt;를 붙이면 뜻이 중복된다는 얘기를 한다.&lt;a href=&#34;#fnref2&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;어떤 사람들은 &lt;q&gt;PIN&lt;/q&gt;이 &lt;q&gt;개인 식별 번호&lt;/q&gt;(personal identification number)의 약자이므로 뒤에 &lt;q&gt;번호&lt;/q&gt;를 붙이면 뜻이 중복된다는 얘기를 한다.&lt;a href=&#34;#fnref3&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>
      
    </entry>
  
    <entry>
      
        
          <title>Metaprogramming and static analysis</title>
        
        <id>http://blog.hongminhee.org/2015/09/29/metaprogramming-and-static-analysis/</id>
        <link rel="alternate" type="text/html" hreflang="ko"
              href="http://blog.hongminhee.org/2015/09/29/metaprogramming-and-static-analysis/" />
        <published>2015-09-29T18:22:21+09:00</published>
        <updated>2015-09-29T18:22:21+09:00</updated>
        <author>
          <name>홍민희</name>
          <uri>http://hongminhee.org/</uri>
          <email>&#104;ongmin&#104;ee&#64;member&#46;fsf&#46;org</email>
        </author>
        <content type="html">&lt;h1 id=&#34;metaprogramming-and-static-analysis&#34;&gt;Metaprogramming and static analysis&lt;/h1&gt;
&lt;p&gt;Lisp으로 대표되는 동적 언어들의 강력함에는 프로그래머가 코딩을 매우 잘하며, 실수를 잘 하지 않는다는 낙관적인 가정이 필요하다. 반면 ML로 대표되는 정적 강타입 언어들의 엄밀함은, 분명 인간은 언제나 실수한다는 비관적인 가정이 깔려 있다.&lt;/p&gt;
&lt;p&gt;이른바 해커 스타일의 프로그래머들은 정적 분석을 좋아하지 않는다. 이들에게는 정적 분석은 &lt;a href=&#34;http://eschew.wordpress.com/2009/08/31/sound-and-complete/&#34;&gt;맞는 코드를 자꾸 틀리다고&lt;/a&gt;(incomplete) 시끄럽게 구는 도구일 뿐이다. 해커들은 혼자 알아서 잘 하기 때문에, 정적 분석과 같이 실수를 줄여주는 기술보다는 메타프로그래밍 같이 반복 작업을 줄이고 생산성을 높여주는 기술을 선호한다.&lt;/p&gt;
&lt;p&gt;그러고 보면 정적 분석과 메타프로그래밍은 실세계 프로그래밍에서 두 방향의 욕구를 각각 대표한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;정적 분석&lt;/strong&gt;은 프로그래머를 &lt;em&gt;늘릴&lt;/em&gt; 수 있게 해준다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;메타프로그래밍&lt;/strong&gt;은 프로그래머를 &lt;em&gt;줄일&lt;/em&gt; 수 있게 해준다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;가장 이상적인 것은 양쪽 모두를 충분히 취하는 것일 것이다.&lt;/p&gt;
&lt;p&gt;예전에 썼던, 관련 있는 내용: &lt;a href=&#34;http://ask.fm/hongminhee/answer/27733312415&#34;&gt;노동 집약적 소프트웨어 개발과 기술 집약적 소프트웨어 개발&lt;/a&gt;.&lt;/p&gt;
</content>
      
    </entry>
  
    <entry>
      
        
          <title>2015년 9월 24일</title>
        
        <id>http://blog.hongminhee.org/2015/09/24/129771467407/</id>
        <link rel="alternate" type="text/html" hreflang="ko"
              href="http://blog.hongminhee.org/2015/09/24/129771467407/" />
        <published>2015-09-24T19:34:51+09:00</published>
        <updated>2015-09-24T19:34:51+09:00</updated>
        <author>
          <name>홍민희</name>
          <uri>http://hongminhee.org/</uri>
          <email>&#104;ongmin&#104;ee&#64;member&#46;fsf&#46;org</email>
        </author>
        <content type="html">&lt;p&gt;텀블러에 글 처음 쓴 게 2010년 2월이니까 이제 만으로는 4년, 5년째 여기다 글을 쓰고 있다. 어쩌다 글 쓴 기록을 쭉 보니까 이제는 거의 달마다 하나 정도 쓰고 있지만, 예전에 일을 전혀 안 할 때는 한달에 5개 정도씩 올리던 때도 있고 그랬다.&lt;/p&gt;
&lt;p&gt;블로깅은 고등학교 졸업 전부터 썼으니까, 그게 아마 2006년 말 정도인 것 같다. 그러면 이제 만으로 9년 정도 썼고, 조금 있으면 10년이다.&lt;/p&gt;
&lt;p&gt;살면서 뭔가 꾸준하게 해온 게 얼마 없는데, 블로깅이 그 중 하나인 것 같다. 의무감이 있었다면 아마 블로깅을 꾸준히 못했을 것이다. 아무런 책임감 없이 오히려 방만하게 블로깅을 했기 때문에 더 오랫동안 써올 수 있었던 것 같다.&lt;/p&gt;
&lt;p&gt;내가 하는 일 치고는 드물게 &lt;q&gt;이제부터 블로깅을 해야지! 그럼 어디 블로그 소프트웨어를 만들어볼까?&lt;/q&gt;라거나 &lt;q&gt;어떤 블로그 서비스가 제일 괜찮을까?&lt;/q&gt;(그리고 5년째 블로그 서비스 비교만 했다고 한다) 같은 yak shaving의 흐름에 빠지지 않았던 것도 좋았다.&lt;/p&gt;
&lt;p&gt;결국 아이러니하게도 처음 시작할 때부터 지금 이때까지도, 블로깅이 쓸모 없는 일이라고 하찮게 생각하고 있어서 꾸준히 하게 되는 것 같다.&lt;/p&gt;
</content>
      
    </entry>
  
    <entry>
      
        
          <title>2015년 9월 24일</title>
        
        <id>http://blog.hongminhee.org/2015/09/24/129770240547/</id>
        <link rel="alternate" type="text/html" hreflang="ko"
              href="http://blog.hongminhee.org/2015/09/24/129770240547/" />
        <published>2015-09-24T18:47:11+09:00</published>
        <updated>2015-09-24T18:47:11+09:00</updated>
        <author>
          <name>홍민희</name>
          <uri>http://hongminhee.org/</uri>
          <email>&#104;ongmin&#104;ee&#64;member&#46;fsf&#46;org</email>
        </author>
        <content type="html">&lt;p&gt;필즈상 수상자 티머시 가워스(Timothy Gowers)는 그의 저서 &lt;a href=&#34;http://www.aladin.co.kr/shop/wproduct.aspx?ISBN=8981729484&#34;&gt;아주 짧게 소개하는 수학&lt;/a&gt;(Mathematics: A Very Short Introduction)에서 &lt;strong&gt;왜 여성 수학자들이 그렇게 적은가?&lt;/strong&gt;라는 질문에 대한 답을 하면서 이런 이야기를 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;한 가지 언급할 만한 점은 수학계에서 여성의 부족은 통계적으로도 특이한 현상이라는 것이다. 매우 훌륭한 여성 수학자들이 존재하고 동료 남성 수학자와 마찬가지로 그들 중 몇몇은 천재이기도 하며 다양한 면에서 뛰어나다. 어떠한 종류든 여성의 수학적 성취에 상한이 있다는 증거는 전혀 없다.&lt;/p&gt;
&lt;p&gt;(…중략…)&lt;/p&gt;
&lt;p&gt;더 그럴듯해 보이는 생각은 사회적 요인이 중요하다는 것이다. 소년은 자신의 수학적 능력에 자부심을 가질 수 있는 반면, 소녀는 여성스럽지 않다고 인식되는 일에 뛰어난 것에 불편해할 수 있다. 게다가 수학적 재능이 있는 소녀들은 역할 모델이 거의 없어서 상황이 악순환된다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;역할 모델(role model)이 거의 없다는 얘기를 보니 19세기 중후반의 러시아 여성 수학자 &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%86%8C%ED%94%BC%EC%95%BC_%EC%BD%94%EB%B0%9C%EB%A0%99%EC%8A%A4%EC%B9%B4%EC%95%BC&#34;&gt;소피야 코발렙스카야&lt;/a&gt;가 수학을 공부하기 위해 겪은 어려움을 함께 읽어보면 좋을 것 같다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;어렸을 때부터 수학에 관심을 가졌으나, 당시 러시아에서는 여성이 대학에 진학하는 것이 금지되었고, 유학을 하려면 아버지나 남편의 허락을 받아야 했다. 이 때문에 소피야는 고생물학자 블라디미르 코발렙스키와 위장 결혼을 하였고, 블라디미르의 &lt;q&gt;허락&lt;/q&gt;을 받아 1867년 독일 하이델베르크 대학교에 유학하여 &lt;a href=&#34;https://ko.wikipedia.org/wiki/%ED%97%A4%EB%A5%B4%EB%A7%8C_%ED%8F%B0_%ED%97%AC%EB%A6%84%ED%99%80%EC%B8%A0&#34;&gt;헤르만 폰 헬름홀츠&lt;/a&gt;와 &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EA%B5%AC%EC%8A%A4%ED%83%80%ED%94%84_%ED%82%A4%EB%A5%B4%ED%9E%88%ED%98%B8%ED%94%84&#34;&gt;구스타프 키르히호프&lt;/a&gt; 아래서 2년 동안 수학을 공부하였으나, 당시 하이델베르크 대학교에서는 여성을 공식적으로 입학시키지 않았다. 그 뒤 베를린으로 이사하였는데, 당시 베를린 훔볼트 대학교는 아예 여성이 강의실에 있는 것조차도 금지하였다. 이 때문에 코발렙스카야는 &lt;a href=&#34;https://ko.wikipedia.org/wiki/%EC%B9%B4%EB%A5%BC_%EB%B0%94%EC%9D%B4%EC%96%B4%EC%8A%88%ED%8A%B8%EB%9D%BC%EC%8A%A4&#34;&gt;카를 바이어슈트라스&lt;/a&gt;로부터 개인 강습을 들어야만 했다.&lt;/p&gt;
&lt;p&gt;(…중략…)&lt;/p&gt;
&lt;p&gt;박사 학위 취득 뒤 코발렙스카야는 빈곤을 피하기 위해 수학 강사가 되려 하였으나, 당시 유럽의 어느 대학교도 여성이 강의하는 것을 허용하지 않았다. 코발렙스카야는 심지어 무료로 강의하는 것을 제안하였으나 여전히 거절당했다. 빈곤에 시달리던 코발렙스카야는 &lt;q&gt;남편&lt;/q&gt; 블라디미르의 상점에서 조수로 일해야만 했다.&lt;/p&gt;
&lt;/blockquote&gt;
</content>
      
    </entry>
  
    <entry>
      
        
          <title>Exploiting Google PageRank using Reddit</title>
        
        <id>http://blog.hongminhee.org/2015/08/30/exploiting-google-pagerank-using-reddit/</id>
        <link rel="alternate" type="text/html" hreflang="ko"
              href="http://blog.hongminhee.org/2015/08/30/exploiting-google-pagerank-using-reddit/" />
        <published>2015-08-30T14:05:31+09:00</published>
        <updated>2015-08-30T14:05:31+09:00</updated>
        <author>
          <name>홍민희</name>
          <uri>http://hongminhee.org/</uri>
          <email>&#104;ongmin&#104;ee&#64;member&#46;fsf&#46;org</email>
        </author>
        <content type="html">&lt;h1 id=&#34;exploiting-google-pagerank-using-reddit&#34;&gt;Exploiting Google PageRank using Reddit&lt;/h1&gt;
&lt;p&gt;2015년 8월 30일 현재, Google에서 TV 프로그램을 받아서 보기 위해 &lt;q&gt;150829 더지니어스&lt;/q&gt; 같은 식으로 검색을 해보면 몇개의 Reddit 스레드가 상위에 노출된다. 눌러서 들어가보면 각 스레드는 각각 전혀 다른 subreddit에 올라온 것들이고, 다운로드 링크가 걸려 있는데 들어가면 웬 웹하드 사이트가 뜬다.&lt;/p&gt;
&lt;p&gt;이는 십중팔구 웹하드 사이트의 스패밍일 것이다. 과거 많이 쓰였던 트랙백 스팸과 같은 수법인데, 랭크가 낮은 웹 페이지를 랭크가 높아질 자격이 있는 것잉 양 검색 엔진을 속이기 위해, 이미 랭크가 높은 웹 페이지에 댓글이나 트랙백 등으로 링크를 걸어서 덩달아 랭크를 높이는 수법이다. 이는 물론 스패밍이며 검색 엔진 어뷰징이다. 다행히 이제 그러한 방식의 스패밍은 포럼 소프트웨어 수준에서 링크를 자동으로 걸어주지 않는 식으로 많이 차단이 된 상태이다.&lt;/p&gt;
&lt;p&gt;Reddit에서는 스팸 역시 단순히 정보성이 낮은, 즉 가치 없는 콘텐트로 일반화해서 다루는데, 흥미 없는 스레드에 다운보트하는 것과 같이 스팸 스레드에도 다운보트하여 목록에서 추락시킨다. 저 아래쪽에 떨어지게 되므로 목록은 빠르게 정화된다. 그렇지만 엄연히 스레드는 목록에서 삭제되는 것은 아닌데, 순위가 내려갈 뿐 목록에는 여전히 포함되어 있는 것이다.&lt;/p&gt;
&lt;p&gt;Reddit은 트래픽이 매우 많은 사이트로, 각각의 subreddit도 대체로 랭크가 매우 높은 편이다. 그러한 노른자 터에 단 몇분이라도 스팸을 노출시킬 수 있다면 그것만으로 Google 검색 결과에서는 상당히 높은 위치에 자리 잡을 수 있게 된다.&lt;/p&gt;
&lt;p&gt;아마 Google 검색 엔진은 내가 상상하는 것보다 훨씬 똑똑할테지만, 문득 PageRank 방식이 &lt;q&gt;웹 페이지에 걸리는 링크는 그 페이지 내용을 만든 사람의 의도로 넣은 것이다&lt;/q&gt;라는 가정을 하고 있었고, 정적인 웹 페이지보다 댓글이 달리는 등의 동적인 웹 페이지가 훨씬 더 많아지면서 시대에 맞지 않는 가정이 된 것이 아닌가 하는 생각이 들었다.&lt;/p&gt;
</content>
      
    </entry>
  
    <entry>
      
        
          <title>2015년 7월 28일</title>
        
        <id>http://blog.hongminhee.org/2015/07/28/125256670592/</id>
        <link rel="alternate" type="text/html" hreflang="ko"
              href="http://blog.hongminhee.org/2015/07/28/125256670592/" />
        <published>2015-07-28T22:40:28+09:00</published>
        <updated>2015-07-28T22:40:28+09:00</updated>
        <author>
          <name>홍민희</name>
          <uri>http://hongminhee.org/</uri>
          <email>&#104;ongmin&#104;ee&#64;member&#46;fsf&#46;org</email>
        </author>
        <content type="html">&lt;p&gt;Flask나 Celery를 쓸 때마다, 두 프로젝트가 최초 사용성을 높이기 위해 장기적으로 손해가 될만한 부분을 감수하고서 도입한 전역 앱 인스턴스 개념과 씨름하게 된다. 두 프로젝트 모두, 전역 앱 인스턴스를 도입해놓고, 또 그것의 한계를 극복 혹은 완화하기 위해 다시 컨텍스트 로컬(context locals) 같은 개념을 끌고 들어왔다.&lt;/p&gt;
&lt;p&gt;그렇다면 그렇게까지 해서 전역 앱 인스턴스 개념을 도입했을 때 얻는 장점이란 무엇인가? 내 생각에는 아마도 최초의 사용성을 극대화하기 위함이 아닐까 한다. Flask 웹 사이트에 가면 대여섯 줄의 예제 코드가 있어서, 그걸 죽 긁어 파일 하나에 붙여서 실행하면 바로 웹 서버 하나 띄울 수 있게 해놨다. 최초 사용에서 만날 수 있는 다양한 어려움을 최대한 없애려고 한 노력이 느껴진다.&lt;/p&gt;
&lt;p&gt;이런 생각을 하다보니 하나의 문제 의식이 떠올랐다. GitHub 이후의 오픈 소스 세상은, GitHub이 발명한 초기의 두 가지 혁신&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 중 하나인 README 표시 기능 덕분에, &lt;em&gt;README 주도 개발&lt;/em&gt;, 내지는 &lt;em&gt;예제 주도 개발&lt;/em&gt;이라고 부를 수 있을 법한 문화를 정착시켰다. 이는 당장 몇 시간 뒤에 퇴근해야 하는 대부분의 프로그래머들이 처음 보는 물건을 살펴보며 받아야 하는 인지 부하(cognitive load)를 상당 부분 줄이게 해주었기 때문에, 그렇게 개발되지 않은 라이브러리/프레임워크에 비해서 더 잘 선택되는 경향이 생기게 됐다.&lt;/p&gt;
&lt;p&gt;이는 곧 신세대 오픈 소스 해커들 사이에 널리 퍼진 미덕이 되었고, 처음 라이브러리를 써보는 사람이 ‘골치 아픈 기분’이나 겁을 느끼지 않고 금방 &lt;q&gt;이걸 써야겠다&lt;/q&gt;하고 생각하도록 최적화를 하는 것도 아주 당연하게 되었다. 달리 말하자면 이건 오픈 소스 세상에서의 마케팅 원칙&lt;a href=&#34;#fn2&#34; class=&#34;footnoteRef&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; 같은 것이 된 것이다.&lt;/p&gt;
&lt;p&gt;몇년이 지난 지금, 우리는 이 미덕의 단점도 슬슬 마주하기 시작했다고 생각한다. 어떤 라이브러리들은 선택받기 위해 ‘첫 경험’을 최적화하다보니, 장기적으로는 큰 짐을 지게 하는 API를 만들기 시작했다. 이 중 심한 것들은 overfitting이 분명하다고 여겨진다. Flask나 Celery의 전역 앱 인스턴스 개념과, 해당 개념이 불러오는 불편함을 해결하기 위해 또다시 끌고 온 컨텍스트 로컬 같은 것들이 대표적인 예라고 느꼈다.&lt;/p&gt;
&lt;p&gt;심각성의 정도는 아주 다르긴 해도, 이는 우리 모두가 아무래도 선정적인 것에 큰 호기심을 느끼고, 그래서 기자들도 제목 낚시(clickbait)를 경쟁적으로 하게 되는 것과 비슷한 현상이라고 느낀다. 둘 모두 기사와 라이브러리를 ‘선택’하게 하려는 노력의 극단적인 형태이고, 선택한 당사자들도 얼마 후 그로부터 괴로움을 얻게 된다는 점에서 유사하다.&lt;a href=&#34;#fn3&#34; class=&#34;footnoteRef&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;가장 좋은 것은 장기적으로도 유연하게 대응할 수 있는 API를 만들고, 그 위에다 첫 경험도 좋게 만들 수 있는 파사드(façade) API를 얹는 것일 게다. 하지만 너무 뻔한 소리고, 이건 누구나 따라할 수 있는 ‘절차’도 아닌 것 같다.&lt;/p&gt;
&lt;section class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;다른 하나는 풀 리퀘스트.&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;심지어 Flask를 만든 Armin Ronacher는 Flask 개발 초기에 &lt;a href=&#34;http://mitsuhiko.pocoo.org/flask-pycon-2011.pdf&#34;&gt;&lt;q&gt;marketing beats quality&lt;/q&gt;라는 소리&lt;/a&gt;까지 했다.&lt;a href=&#34;#fnref2&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;물론 둘 사이에는 엄청나게 차이점이 많다. 일부의 특성을 들어 비유했을 뿐이다.&lt;a href=&#34;#fnref3&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>
      
    </entry>
  
    <entry>
      
        
          <title>Continuous Design and the NoPSD Movement</title>
        
        <id>http://blog.hongminhee.org/2015/06/23/continuous-design-and-the-nopsd-movement/</id>
        <link rel="alternate" type="text/html" hreflang="ko"
              href="http://blog.hongminhee.org/2015/06/23/continuous-design-and-the-nopsd-movement/" />
        <published>2015-06-23T00:49:11+09:00</published>
        <updated>2015-06-23T00:49:11+09:00</updated>
        <author>
          <name>홍민희</name>
          <uri>http://hongminhee.org/</uri>
          <email>&#104;ongmin&#104;ee&#64;member&#46;fsf&#46;org</email>
        </author>
        <content type="html">&lt;h1 id=&#34;continuous-design-and-the-nopsd-movementsource&#34;&gt;&lt;a href=&#34;http://thoughtworks.github.io/p2/issue02/continuous-design/&#34;&gt;Continuous Design and the NoPSD Movement&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;회사 슬랙에서 &lt;a href=&#34;http://kimbyeonghwan.tumblr.com/&#34;&gt;김병환&lt;/a&gt; 님이 &lt;a href=&#34;http://thoughtworks.github.io/p2/issue02/continuous-design/&#34;&gt;연속적 디자인과 NoPSD 운동에 대한 글&lt;/a&gt;을 링크해주셔서 읽게 되었다. 이미 연속적인 과정으로 개발하는 방식에 확신을 가진지 오래된 프로그래머로서 글의 많은 부분에 동의하는 바이나, 읽고나서 든 생각은 &lt;q&gt;그런데 정작 당사자들에게 공감을 얻을 수 있을까?&lt;/q&gt;였다.&lt;/p&gt;
&lt;p&gt;나는 저런 내용이 당사자들에게는 공감을 얻어내기 힘들다고 생각한다.&lt;/p&gt;
&lt;p&gt;프로그래머들은 이미 현재 누리고 있는 개발 방식에 익숙해져 있기 때문에 쉽게 잊곤 하지만, &lt;a href=&#34;https://www.quora.com/How-would-Donald-Knuth-fare-as-a-competitor-on-TopCoder-today/answer/Michael-Hayter&#34;&gt;Donald Knuth가 회상하듯&lt;/a&gt; 옛날 프로그래머들은 원래 &lt;q&gt;돌에 새기듯 프로그래밍하는 것을 배웠다.&lt;/q&gt;&lt;/p&gt;
&lt;p&gt;건축을 비롯해 &lt;strong&gt;처음부터 완벽하고 올바른 설계를 하는 것&lt;/strong&gt;을 강조하는 많은 분야들에는 하나 같이 대동소이한 정당화가 존재한다. &lt;q&gt;한번 만들면 바꿀 수 없다.&lt;/q&gt; 그러나 그러한 특성은 프로그래밍에도 존재하던 것이었다. 컴퓨터 프로그램은 모든 부분이 논리적으로 정확하게 맞물려 한치의 오차도 없이 맞아 떨어져야 한다. 그 와중에 일치하지 않는 것, 일관성이 깨지는 부분이 있다면 프로그램은 단지 보기에 나빠지는 것이 아니라, 오류가 나며 동작하지 않게 된다. 컴퓨터 프로그램은 작성하고 나면 방대하고 복잡해질 수밖에 없어서, 과장하면 거의 쓰기 전용(write-only)이었다. 프로그래밍은 본래 천성적으로 &lt;q&gt;처음부터 완성된 채로 만들어져야 하는&lt;/q&gt; 작업이었다. Paul Graham은 그의 유명한 에세이 &lt;a href=&#34;http://paulgraham.com/hp.html&#34;&gt;해커와 화가&lt;/a&gt;에서 어렸을 적 자신이 처음부터 올바른 설계를 하는 식으로 프로그래밍하지 못하는 것에 대해 부끄럽게 여겼다는 고백을 한다. 소프트웨어 공학은 한동안 건축의 메타포를 버리지 못했다. (그리고 지금도 어느 정도는 여전하다.)&lt;/p&gt;
&lt;p&gt;물론 이는 오래된 이야기이다. 현대의 소프트웨어 개발은 점진적이며, duct tape programmer라는 말도 생겼을 만큼 &lt;q&gt;얼기설기&lt;/q&gt; 만들어서 &lt;q&gt;조금씩 고쳐나가는&lt;/q&gt; 것이 가능해졌을 뿐만 아니라, 그러한 것을 오히려 바람직한 개발 방식으로 본다. 이렇게 프로그래머 공동체의 관점이 크게 바뀐 것에는 &lt;a href=&#34;http://agilemanifesto.org/iso/ko/&#34;&gt;애자일 선언&lt;/a&gt;이나 스타트업 열기도 중요한 역할을 했겠으나, 나는 이 글에서 흔히 고려되지 않는 또 다른 요인도 꺼내볼까 한다.&lt;/p&gt;
&lt;p&gt;소프트웨어 개발이 점진적일 수 있게 된 이유는, 점진적으로 소프트웨어 개발을 빠르고 쉽게 할 수 있는 충분한 도구가 &lt;em&gt;아주 많이&lt;/em&gt; 주어졌기 때문이다. 그리고 그러한 도구가 &lt;em&gt;아주 많이&lt;/em&gt; 생겨날 수 있었던 이유는, 프로그래밍이라는 작업의 특수성에 기인한다.&lt;/p&gt;
&lt;p&gt;소프트웨어 개발이 발전함에 따라 프로그래머 사회는 아주 특이한 양상을 띄게 되었다. &lt;q&gt;장인은 도구 탓을 하지 않는다&lt;/q&gt;라는 기존 다른 분야의 격언에 역행하는 방향으로 가게 된 것이다.&lt;/p&gt;
&lt;p&gt;많은 프로그래머들은 &lt;q&gt;우리가 도구를 어떻게 써야 하는지&lt;/q&gt;보다 &lt;q&gt;우리가 쓰는 도구가 어땠어야 하는지&lt;/q&gt;에 점차 집중하기 시작했다. &lt;q&gt;장인은 도구 탓을 하지 않는다&lt;/q&gt; 내지는 &lt;q&gt;도구는 도구일 뿐&lt;/q&gt;과 같은 격언은 대부분의 분야에서 아주 중요한 가르침을 준다. 자신이 직접 통제할 수 없는 요소에는 헛된 노력을 투입하지 말고, 통제할 수 있는 영역에만 노력을 집중하라는 것이다. 여기서 중요한 부분은, &lt;em&gt;자신이 통제할 수 있는 영역이라면, 노력을 들일 이유가 생긴다는 것이다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;악기 연주자는 본인의 악기에 불평할 수는 있어도, 만족할만한 더 좋은 악기를 만들어내지는 않는다. 연주자가 악기에 대한 불평을 해봤자 대체로 비생산적인 일이다. 그래봤자 악기를 좋게 만들 수 없기 때문이다. &lt;q&gt;도구 탓을 하지 말라&lt;/q&gt;는 이야기는 그런 맥락으로 이해해야 한다.&lt;/p&gt;
&lt;p&gt;반면, 프로그래머들은 아주 운이 좋게도 &lt;em&gt;스스로의 도구를 고치거나 만들어낼 수 있었다.&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;머릿속에 한번에 담을 수 없는 많은 수의 상태를 머릿속으로 추적하며 디버깅하기 어려웠기 때문에, (순간 기억력을 늘리려는 노력을 하기보다) &lt;strong&gt;디버거&lt;/strong&gt;를 만들었다.&lt;/li&gt;
&lt;li&gt;기계어로 사소한 곳까지 긴 코드를 써가며 코딩하는 것이 어려웠기 때문에, (폰 노이만처럼 기계어에 능숙해지는 대신) 기계보다는 수학이나 인간 언어에 가까운 &lt;strong&gt;높은 추상화 수준의 언어&lt;/strong&gt;를 만들고, 그 언어를 기계어로 번역해주는 &lt;strong&gt;컴파일러&lt;/strong&gt;도 만들었다.&lt;/li&gt;
&lt;li&gt;소스 코드가 길고 복잡해지면 한눈에 파악하는 것이 어려워졌기 때문에, (소스 코드 읽는 수련을 하는 대신) &lt;strong&gt;구문 강조&lt;/strong&gt;와 &lt;strong&gt;통합 개발 도구&lt;/strong&gt;(IDE)를 만들었다.&lt;/li&gt;
&lt;li&gt;처음에 세웠던 가정들이 중간에 깨질 때마다, 그 가정에 기대어 만들었던 방대한 코드를 모두 찾아가며 고치는 것이 어렵고 버그가 생기기 쉬웠기 때문에, &lt;strong&gt;리팩토링 도구&lt;/strong&gt;를 만들었다.&lt;/li&gt;
&lt;li&gt;코드를 약간만 고쳐도 소프트웨어의 모든 부분이 여전히 잘 동작한다는 것을 보장하려면, 수정할 때마다 사람이 많은 시간을 들여 전체 기능 체크 리스트를 들고 전수 검사를 해야했는데, 이걸 자동화할 &lt;strong&gt;테스트 자동화&lt;/strong&gt; 기술을 만들었다.&lt;/li&gt;
&lt;li&gt;다양한 소프트웨어를 만들면서도 비슷한 기능을 매번 새로 만드는 것이 불편하고 시간이 낭비되었기 때문에, 의존성을 나열하고 명령어 하나만 치면 필요한 라이브러리가 알아서 받아서 설치되고 빌드까지 되게 하는 &lt;strong&gt;패키지 시스템&lt;/strong&gt;을 만들었다.&lt;/li&gt;
&lt;li&gt;여러 사람이 거대한 시스템의 부분을 고치다보면 동시에 여러 사람이 한 군데를 건드리는 경우가 생기곤 했는데, 그러한 수정 사항들을 안전하게 합치기 위해 Git과 같은 &lt;strong&gt;버전 관리 시스템&lt;/strong&gt;을 만들었다.&lt;/li&gt;
&lt;li&gt;사소한 기능 수정을 할 때마다 프로그래머의 작업용 컴퓨터에서 전체 테스트를 돌리고 새로운 빌드를 만들어서 사용자들에게 전달하는 것이 귀찮았기 때문에, 프로그램을 수정할 때마다 자동으로 그 모든 것을 해주는 &lt;strong&gt;CI&lt;/strong&gt;를 만들었다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;나열하자면 끝이 없다. 위에서 언급한 것들은 굵직한 발명들만 모은 것이다. 어떤 프로젝트든 어느 정도 시간이 지나면 개발의 편의를 위해 만들어내는 내부 발명품들이 쌓여간다. 이를 아예 일반화하고 오픈 소스로 공개하는 경우도 아주 많다. 위에서 말한 도구들은 정확히는 도구의 분류에 가까워서, 가령 프로그래밍 언어는 하나가 아닐 뿐 아니라 지난 몇십년간 여러 언어들 사이에 끝없는 전쟁이 이어져 왔다. 재능 있는 프로그래머 지망생은 누구나 자신에게 꼭 맞는 운영체제나 프로그래밍 언어를 구현해볼 마음을 품는다. 그리고 상당히 많이들, 실제로 만들어낸다.&lt;/p&gt;
&lt;p&gt;이는 디자이너로 치면 &lt;q&gt;재능 있는 디자이너라면 누구나 자신에게 꼭 맞는 포토샵 대체품을 만들어볼 마음을 품는다&lt;/q&gt; 같은 얘기가 되며, 악기 연주자로 치면 &lt;q&gt;누구나 자신에게 꼭 맞는 악기를 만들어볼 마음을 품는다&lt;/q&gt; 같은 얘기가 된다. 분야가 달라지니 상당히 다르게 받아들여진다.&lt;/p&gt;
&lt;p&gt;그러나 프로그래머들이 명심해야 할 점은, 그러한 분야의 발전이 더딘 것이 아니라, 프로그래머 사회가 매우 이상한 특성을 가진 것이라는 사실이다. 프로그래머 공동체의 이러한 경향은 다른 직업 공동체에서는 쉽게 공감을 얻기 힘든 생소한 태도이다.&lt;/p&gt;
&lt;p&gt;프로그래머 공동체는 앞으로도 더 많은 도구를 만들어내고, 더 자주 개선할 것이다. 그러한 개선된 도구를 가지고, 또 도구 그 자체를 빠르게 만들어내는 데에 활용할 것이다. 프로그래머들은 점점 큰 걸음을 손짓 하나로 할 수 있게 되면서, 프로그램은 아무때건 얼마든지 고칠 수 있다는 아이디어에 자신감을 얻을 것이다.&lt;a href=&#34;#fn1&#34; class=&#34;footnoteRef&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;그렇다면 소프트웨어 분야의 다른 직군들은 어떻게 &lt;q&gt;점진적으로 만들어가는&lt;/q&gt; 아이디어에 확신을 얻을 수 있게 될까? 글을 열심히 읽어준 분들께는 허탈하게 해서 죄송하지만, 나로서는 계속 고민하고 있을 뿐 아직 답을 못 찾았다. 현재로서는 개개인의 탁월함에 기대는 것이 한계이다. 훌륭한 작업을 빠른 시간 안에 해내는 능숙한 동료가 있다면, 빠르고 점진적으로 제품을 만들어나가는 방식에 발을 기꺼이 맞춰줄 것이다. 하지만 이것이 대부분의 평범한 동료들에게도 요구할 수 있는 덕목인지는 여전히 확신이 들지 않는다. 그러니까, 나는 ‘애자일한 제품 개발’이라는 것이 과연 프로그래밍 이외의 영역에도 쉽게 전이될 수 있는 방식인지에 대해 의문이 생긴다.&lt;/p&gt;
&lt;p&gt;덧. 최근 회사 동료들과 얘기를 하면서 이러한 의문을 품기 시작했습니다. &lt;a href=&#34;http://www.spoqa.com/&#34;&gt;스포카&lt;/a&gt;는 좋은 동료들과 일할 수 있는 좋은 회사입니다. 스포카는 웹 프론트엔드/안드로이드/iOS 개발자를 구하고 있습니다. &lt;del&gt;기승전구인&lt;/del&gt;&lt;/p&gt;
&lt;section class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;이런 주장은 반면 프로그래머에게 덜 공감될 여지도 있을텐데, 프로그래머끼리는 함께 생산성이 높아지기 때문에 분야 자체의 개발 속도가 빨라진다는 느낌을 잘 받지 못하기 때문이다. 하지만 ‘5명으로 5주동안 만들 수 있는 것’이 15년 전에서 지금까지 어떤 식으로 바뀌었는지 생각해보면 많은 발전을 느낄 수 있다.&lt;a href=&#34;#fnref1&#34;&gt;↩&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</content>
      
    </entry>
  
    <entry>
      
        
          <title>2015년 6월 15일</title>
        
        <id>http://blog.hongminhee.org/2015/06/15/121589881537/</id>
        <link rel="alternate" type="text/html" hreflang="ko"
              href="http://blog.hongminhee.org/2015/06/15/121589881537/" />
        <published>2015-06-15T23:14:21+09:00</published>
        <updated>2015-06-15T23:14:21+09:00</updated>
        <author>
          <name>홍민희</name>
          <uri>http://hongminhee.org/</uri>
          <email>&#104;ongmin&#104;ee&#64;member&#46;fsf&#46;org</email>
        </author>
        <content type="html">&lt;p&gt;컴퓨터와 인터넷 안에서 일어나는 일이 일상의 많은 부분을 차지하는 사람들이 이미 많아졌으리라 본다. 내가 바로 그렇다. 앞으로는 더욱 그럴 것이다.&lt;/p&gt;
&lt;p&gt;그러면 언젠가는 컴퓨터 안쪽에서 일어나는 일들, 이를테면 댓글이 달리면 노티가 오는 식의 &lt;q&gt;일상적으로&lt;/q&gt; 일어나는 UI 인터랙션들, 브라우저에서 새 탭을 열면 무의식적으로 &lt;kbd&gt;f&lt;/kbd&gt; 키를 누르고 그걸 또 페이스북으로 자동 완성해주는 브라우저, 그리고 엔터 쳐서 또 페이스북에 들어가버리고 마는 식의 소프트웨어에 대한 나의 &lt;q&gt;습관&lt;/q&gt;, 키보드 커서가 껌뻑이는 모습, 마우스 커서가 어디로 사라졌는지 찾지 못해 헤맬 적, 읽지 않아 밀려 있는 메일함에 떠있는 빨간 풍선 숫자, 같은 것들을 덤덤하게 묘사하는 소설도 흔해질까 싶다.&lt;/p&gt;
</content>
      
    </entry>
  
    <entry>
      
        
          <title>2015년 5월 30일</title>
        
        <id>http://blog.hongminhee.org/2015/05/30/120242271287/</id>
        <link rel="alternate" type="text/html" hreflang="ko"
              href="http://blog.hongminhee.org/2015/05/30/120242271287/" />
        <published>2015-05-30T13:42:06+09:00</published>
        <updated>2015-05-30T13:42:06+09:00</updated>
        <author>
          <name>홍민희</name>
          <uri>http://hongminhee.org/</uri>
          <email>&#104;ongmin&#104;ee&#64;member&#46;fsf&#46;org</email>
        </author>
        <content type="html">&lt;p&gt;iTunes 최근 버전 기준으로 &lt;em&gt;Artists&lt;/em&gt; 혹은 &lt;em&gt;Albums&lt;/em&gt; 뷰로 보면 &lt;em&gt;Recently Added&lt;/em&gt;라는 항목이 맨 위에 나온다. 말 그대로 최근 몇주 사이에 추가된 음악만 추려서 앨범 단위로 보여준다.&lt;/p&gt;
&lt;p&gt;iOS 내장 Music 앱에도 &lt;em&gt;Recently Added&lt;/em&gt;가 스마트 플레이리스트로 있긴 하나 이건 앨범 단위가 아니라 곡 단위다. 순서 역시 마지막에 추가된 게 가장 위가 아니라 가장 아래쪽에 정렬되어 있다. CD 립을 뜨면 앨범에서 가장 마지막 트랙이 가장 나중에 추가될테니, 앨범의 목록이 아니라 곡의 목록인 스마트 플레이리스트로는 최근 추가된 순서로 해버리면 앨범의 트랙은 역순으로 정렬되는 문제 때문에 어쩔 수가 없다. 그리고 아마도 iOS에서는 스마트 플레이리스트가 실시간으로 만들어지는 게 아니라, 주기적인 배치 작업으로 만들어지는 모양이다.&lt;/p&gt;
&lt;figure data-orig-width=&#34;750&#34; data-orig-height=&#34;1334&#34; class=&#34;tmblr-full&#34;&gt;&lt;img data-orig-width=&#34;750&#34; data-orig-height=&#34;1334&#34; src=&#34;https://41.media.tumblr.com/3501a6fb49f889b32e99372e64cfb455/tumblr_inline_np5bnrPbTO1qz6t91_540.png&#34;&gt;&lt;/figure&gt;
&lt;p&gt;Google Play Music에도 iTunes와 비슷한 기능을 제공하는데 좀더 편하다. 최근 추가된 앨범 뿐만 아니라, 최근에 들었던 앨범도 가장 첫 화면에 보여준다. 좋은 레이블인지는 모르겠지만 &lt;em&gt;Listen Now&lt;/em&gt;라는 이름의 화면이다.&lt;/p&gt;
&lt;figure data-orig-width=&#34;750&#34; data-orig-height=&#34;1334&#34; class=&#34;tmblr-full&#34;&gt;&lt;img data-orig-width=&#34;750&#34; data-orig-height=&#34;1334&#34; src=&#34;https://40.media.tumblr.com/9ea750b078b0b4af96de3589996cfca7/tumblr_inline_np5bn1gfqW1qz6t91_540.png&#34;&gt;&lt;/figure&gt;
&lt;p&gt;CD나 음원을 자주 구입하고 앨범 단위로 음악을 듣는 사람에게는 &lt;em&gt;Listen Now&lt;/em&gt; 방식이 제일 편한 것 같다.&lt;/p&gt;
</content>
      
    </entry>
  
    <entry>
      
        
          <title>2015년 5월 25일</title>
        
        <id>http://blog.hongminhee.org/2015/05/25/119818974082/</id>
        <link rel="alternate" type="text/html" hreflang="ko"
              href="http://blog.hongminhee.org/2015/05/25/119818974082/" />
        <published>2015-05-25T12:27:12+09:00</published>
        <updated>2015-05-25T12:27:12+09:00</updated>
        <author>
          <name>홍민희</name>
          <uri>http://hongminhee.org/</uri>
          <email>&#104;ongmin&#104;ee&#64;member&#46;fsf&#46;org</email>
        </author>
        <content type="html">&lt;p&gt;처음으로 사용해본 스마트폰이 2009년 말에 KT가 한국에 처음으로 들여온 iPhone 3Gs였고, &lt;a href=&#34;http://www.fsf.org/news/2010-05-app-store-compliance&#34;&gt;앱스토어 약관이 GPL과 충돌하여 GPL 앱을 올리지 못하는&lt;/a&gt; 등의 지점에서 반발감을 느껴서 Galaxy Nexus로 안드로이드를 쓰기 시작한 게 2012년 초. 매우 소심하고 별 영향력도 없는 보이콧이 아닐 수 없다. 그 이후로 몇년간 안드로이드를 만족하며 써오다가, 최근까지 쓰던 Nexus 5가 고장나 버렸다.&lt;/p&gt;
&lt;p&gt;서비스 센터에 갔더니 이래저래 30만원 가까히 든다며 그냥 새 폰 사는 게 나을 수도 있다는 소리까지 들었다. 안드로이드를 계속 쓴다면 Nexus 5 이상으로 만족할만한 제품이 없다는 생각이 들었고, 어차피 할부 없이 샀던 전화기라 바꾸는 것도 마음에 부담이 적었다. 최근에 iOS를 써본 일이 없으니 iPhone을 다시 써봐야겠다는 생각이 들어서 iPhone 6를 구입했다.&lt;/p&gt;
&lt;p&gt;사설이 길었는데, Apple 제품의 마감이 훌륭한 것은 누구나 아는 사실이다. 안드로이드도 (&lt;a href=&#34;https://twitter.com/hongminhee/status/598378487964041216&#34;&gt;레퍼런스 제품에 한정, 그 외 제조사가 소프트웨어를 손댄 것은 모두 엉망이지만&lt;/a&gt;) 지난 몇년간 마감이 부쩍 좋아졌지만, 여전히 Apple 제품을 따라가지는 못한다.&lt;/p&gt;
&lt;p&gt;하지만 오랜만에 iOS를 써보니 적응이 되지 않아 불편한 점들이 있다. 하지만 정말로 불편한 것은 백 버튼이 없는 것도 아니고, &lt;a href=&#34;http://www.cnet.com/news/mozilla-says-no-plans-to-return-to-ios/&#34;&gt;여전히 사악한 앱스토어 정책 때문에 iOS용 Firefox가 없다&lt;/a&gt;는 것도 아니였다.&lt;/p&gt;
&lt;p&gt;iOS에 없는 것중 내게 치명적인 것은 OS 수준의 &lt;a href=&#34;http://en.wikipedia.org/wiki/Dependency_injection&#34;&gt;DI&lt;/a&gt;인 것 같다. iOS의 모든 앱들은 중립적인 공통 인터페이스로 통신하기 보다는 대체로 구현 자체가 서로 hardwired되어 있는 식이어서, 가령 IRCCloud 같이 어느 정도 사려 깊은 앱은 링크를 누르면 Safari에서 열지 Chrome으로 열지 직접 물어봐주는 정도다. Google에서 만든 Inbox by Gmail 앱은 링크를 누르면 멋대로 묻지도 않고 Chrome으로 열어버리고 (Safari를 배제하려는 것일 게다), 대부분의 앱들은 그냥 Safari로 열지도 않고 앱 안에 들어있는 브라우저로 링크를 열어버린다. 그 링크를 카카오톡이나 라인 메신저로 다른 사람에게 보내는 방법은 대개는 없다. 다음카카오나 라인에서 만든 앱이 아니라면. 아, 물론 링크를 복사해서 메신저를 직접 켜서 붙여서 전송하는 방법은 있다.&lt;/p&gt;
&lt;p&gt;이러한 생태계는 소프트웨어의 정당한 경쟁조차도 쓸모 없게 만든다는 점에서, 사용자 뿐만 아니라 개발자에게도 좋지 않다. iOS에서는 기본으로 내장된 앱보다 더 좋은 무언가를 만들 동기가 매우 적으며, 더 좋은 무언가를 시도해도 OS 수준의 DI가 없기 때문에 사용자가 default를 바꾸기가 힘들어서 결국 패배하는 역사를 반복해왔다. 그리고 다음 버전의 iOS에는 감쪽같이 패배했던 앱이 개선한 부분을 도입해서 발표한다. (이는 iOS만의 방식이라기 보다는 Apple이 항상 그래왔던 부분이기도 하다.)&lt;/p&gt;
&lt;p&gt;노파심에 덧붙이지만, 나는 Apple 제품이 훌륭하다고 생각한다. 이 글은 Apple 제품의 품질에 대한 불평이 아니라, 서드파티 개발자를 대하는 태도에 관한 불평이다.&lt;/p&gt;
</content>
      
    </entry>
  
</feed>
